name: File Overflow and Error Prevention

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  file-validation:
    runs-on: ubuntu-latest
    timeout-minutes: 15
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pathlib humanize
          
      - name: Check file sizes and prevent overflow
        run: |
          python << 'EOF'
          import os
          import sys
          from pathlib import Path
          
          # Configuration
          MAX_FILE_SIZE_MB = 100  # Maximum individual file size in MB
          MAX_TOTAL_SIZE_MB = 500  # Maximum total repository size in MB
          EXCLUDED_DIRS = {'.git', '__pycache__', '.pytest_cache', 'node_modules', 'venv', '.venv', 'htmlcov'}
          EXCLUDED_EXTENSIONS = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.dylib'}
          
          issues = []
          total_size = 0
          file_count = 0
          
          def format_size(size_bytes):
              """Format bytes to human readable format"""
              for unit in ['B', 'KB', 'MB', 'GB']:
                  if size_bytes < 1024.0:
                      return f"{size_bytes:.2f} {unit}"
                  size_bytes /= 1024.0
              return f"{size_bytes:.2f} TB"
          
          def should_skip(path):
              """Check if path should be skipped"""
              parts = Path(path).parts
              return any(excluded in parts for excluded in EXCLUDED_DIRS)
          
          print("üîç Scanning repository for file size issues...\n")
          
          # Scan all files
          for root, dirs, files in os.walk('.'):
              # Filter out excluded directories
              dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]
              
              for file in files:
                  file_path = os.path.join(root, file)
                  
                  # Skip excluded extensions
                  if any(file.endswith(ext) for ext in EXCLUDED_EXTENSIONS):
                      continue
                  
                  try:
                      size = os.path.getsize(file_path)
                      total_size += size
                      file_count += 1
                      
                      # Check individual file size
                      size_mb = size / (1024 * 1024)
                      if size_mb > MAX_FILE_SIZE_MB:
                          issues.append(f"‚ö†Ô∏è  Large file: {file_path} ({format_size(size)})")
                  except (OSError, FileNotFoundError) as e:
                      issues.append(f"‚ùå Error reading file: {file_path} - {str(e)}")
          
          # Print statistics
          print(f"üìä Repository Statistics:")
          print(f"   Total files scanned: {file_count}")
          print(f"   Total size: {format_size(total_size)}")
          print(f"   Average file size: {format_size(total_size / file_count if file_count > 0 else 0)}")
          print()
          
          # Check total repository size
          total_size_mb = total_size / (1024 * 1024)
          if total_size_mb > MAX_TOTAL_SIZE_MB:
              issues.append(f"‚ö†Ô∏è  Repository size ({format_size(total_size)}) exceeds maximum ({MAX_TOTAL_SIZE_MB} MB)")
          
          # Report findings
          if issues:
              print("\n‚ö†Ô∏è  Issues Found:\n")
              for issue in issues:
                  print(issue)
              print("\nüí° Recommendations:")
              print("   - Use Git LFS for large files")
              print("   - Compress large data files")
              print("   - Move large assets to external storage")
              print("   - Add large files to .gitignore")
              sys.exit(1)
          else:
              print("‚úÖ All file size checks passed!")
              print("   No file overflow issues detected.")
          EOF
          
      - name: Check for common file errors
        run: |
          python << 'EOF'
          import os
          import json
          import sys
          from pathlib import Path
          
          errors = []
          warnings = []
          
          print("üîç Checking for common file errors...\n")
          
          # Check JSON files
          for json_file in Path('.').rglob('*.json'):
              if '.git' in str(json_file) or '__pycache__' in str(json_file):
                  continue
              try:
                  with open(json_file, 'r', encoding='utf-8') as f:
                      json.load(f)
                  print(f"‚úÖ Valid JSON: {json_file}")
              except json.JSONDecodeError as e:
                  errors.append(f"‚ùå Invalid JSON in {json_file}: {str(e)}")
              except UnicodeDecodeError as e:
                  errors.append(f"‚ùå Encoding error in {json_file}: {str(e)}")
              except Exception as e:
                  warnings.append(f"‚ö†Ô∏è  Could not validate {json_file}: {str(e)}")
          
          # Check Python files for syntax errors
          print("\nüêç Checking Python files...")
          for py_file in Path('.').rglob('*.py'):
              if '.git' in str(py_file) or '__pycache__' in str(py_file) or 'venv' in str(py_file):
                  continue
              try:
                  with open(py_file, 'r', encoding='utf-8') as f:
                      compile(f.read(), str(py_file), 'exec')
                  print(f"‚úÖ Valid Python: {py_file}")
              except SyntaxError as e:
                  errors.append(f"‚ùå Syntax error in {py_file}: Line {e.lineno}: {str(e)}")
              except UnicodeDecodeError as e:
                  errors.append(f"‚ùå Encoding error in {py_file}: {str(e)}")
              except Exception as e:
                  warnings.append(f"‚ö†Ô∏è  Could not compile {py_file}: {str(e)}")
          
          # Check for files with null bytes
          print("\nüîç Checking for corrupted files...")
          for file_path in Path('.').rglob('*'):
              if file_path.is_file() and '.git' not in str(file_path):
                  try:
                      with open(file_path, 'rb') as f:
                          content = f.read(1024)  # Read first 1KB
                          if b'\x00' in content and not any(str(file_path).endswith(ext) for ext in ['.pyc', '.so', '.dll', '.exe', '.bin']):
                              warnings.append(f"‚ö†Ô∏è  File may be corrupted (contains null bytes): {file_path}")
                  except Exception:
                      pass  # Skip unreadable files
          
          # Report results
          print("\n" + "="*60)
          if errors:
              print("\n‚ùå ERRORS FOUND:\n")
              for error in errors:
                  print(error)
          
          if warnings:
              print("\n‚ö†Ô∏è  WARNINGS:\n")
              for warning in warnings:
                  print(warning)
          
          if not errors and not warnings:
              print("\n‚úÖ All file validation checks passed!")
          elif not errors:
              print("\n‚úÖ No critical errors found (warnings only)")
          else:
              print("\nüí° Please fix the errors above before merging.")
              sys.exit(1)
          EOF
          
      - name: Check for missing required files
        run: |
          python << 'EOF'
          import os
          import sys
          
          required_files = [
              'README.md',
              'LICENSE',
              'requirements.txt',
              '.gitignore'
          ]
          
          missing = []
          print("üîç Checking for required files...\n")
          
          for file in required_files:
              if os.path.exists(file):
                  print(f"‚úÖ Found: {file}")
              else:
                  missing.append(file)
                  print(f"‚ùå Missing: {file}")
          
          if missing:
              print(f"\n‚ö†Ô∏è  Missing {len(missing)} required file(s).")
              print("   Consider adding these files for better project structure.")
              # Don't fail on missing files, just warn
          else:
              print("\n‚úÖ All required files present!")
          EOF
          
      - name: Generate validation report
        if: always()
        run: |
          echo "## File Validation Report" > validation_report.md
          echo "" >> validation_report.md
          echo "**Date:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> validation_report.md
          echo "**Branch:** ${{ github.ref }}" >> validation_report.md
          echo "**Commit:** ${{ github.sha }}" >> validation_report.md
          echo "" >> validation_report.md
          echo "### Checks Performed" >> validation_report.md
          echo "- ‚úÖ File size validation" >> validation_report.md
          echo "- ‚úÖ JSON syntax validation" >> validation_report.md
          echo "- ‚úÖ Python syntax validation" >> validation_report.md
          echo "- ‚úÖ Corruption detection" >> validation_report.md
          echo "- ‚úÖ Required files check" >> validation_report.md
          echo "" >> validation_report.md
          echo "All validation checks completed successfully!" >> validation_report.md
          cat validation_report.md
          
      - name: Upload validation report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: validation-report
          path: validation_report.md
          retention-days: 30
